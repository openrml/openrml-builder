# ADR-003: IndexedDB для хранения ролей, localStorage для настроек

**Статус:** Принято  
**Дата:** 2026-02-19  
**Авторы:** Основные контрибьюторы

---

## Контекст

Приложение работает полностью на стороне клиента — серверного хранилища нет и, согласно принципу локальности данных (см. `FOUNDATION.md`), быть не должно. Все данные пользователя хранятся в браузере.

В браузере доступно несколько механизмов хранения:

| Механизм | Синхронный | Лимит | Транзакции | Устойчивость |
|----------|-----------|-------|-----------|--------------|
| `localStorage` | Да | ~5–10 МБ | Нет | Средняя |
| `sessionStorage` | Да | ~5–10 МБ | Нет | Только до закрытия вкладки |
| `IndexedDB` | Нет (async) | Сотни МБ+ | Да | Высокая |
| `Cache API` | Нет (async) | Зависит от квоты | Нет | Средняя |

Нужно было выбрать, где хранить:
1. **Роли** — основные пользовательские данные (сложные объекты, могут быть десятки и больше)
2. **Настройки** — язык интерфейса, тема (плоские примитивы, меняются редко)
3. **Кеш шаблонов** — предзагруженные шаблоны для Dashboard (временные, не пользовательские)

---

## Решение

**Роли → IndexedDB** (`openrml-roles-db`)  
**Настройки → localStorage** (`openrml-settings`)  
**Кеш шаблонов → sessionStorage** (`openrml-template-cache`)

Реализовано через `CompositeStorageAdapter`, который инкапсулирует логику выбора хранилища:

```typescript
export class CompositeStorageAdapter implements StoragePort {
  private settingsStorage = new LocalStorageAdapter('openrml-settings');
  private rolesStorage    = new IndexedDBAdapter('openrml-roles-db');
  private templateCache   = new SessionStorageAdapter('openrml-template-cache');
}
```

---

## Почему IndexedDB для ролей

### 1. Объём данных

Полная роль с 8 шагами, сессиями, этическими правилами и лицензией — это несколько килобайт JSON. При библиотеке в 50–100 ролей суммарный объём легко превышает 500 КБ. localStorage имеет лимит ~5–10 МБ в зависимости от браузера и домена, и этот лимит общий для всего сайта. При агрессивном использовании (большие библиотеки ролей, длинные описания сессий) лимит достижим.

IndexedDB не имеет жёсткого фиксированного лимита — браузер управляет квотой динамически, типично 50%+ доступного дискового пространства.

### 2. Устойчивость к очистке браузера

localStorage и IndexedDB ведут себя по-разному при различных сценариях очистки:

| Сценарий | localStorage | IndexedDB |
|----------|-------------|-----------|
| Очистка кук | Сохраняется | Сохраняется |
| «Очистить данные сайта» | Удаляется | Удаляется |
| Режим инкогнито | Изолирован | Изолирован |
| ITP (Safari) агрессивная очистка | **Удаляется через 7 дней без визита** | Более устойчив |
| PWA установлено | Общий с браузером | Общий с браузером |

Safari с включённым Intelligent Tracking Prevention исторически агрессивнее очищает localStorage для сайтов без регулярных визитов. IndexedDB в контексте установленного PWA устойчивее к этой очистке.

### 3. Транзакционность

`LocalStorageAdapter.save()` — это синхронный `localStorage.setItem()`, завёрнутый в async-обёртку для совместимости с `StoragePort`. Атомарности нет: если сохранение прерывается (закрытие браузера в момент записи), данные могут оказаться в частично записанном состоянии.

`IndexedDBAdapter.save()` использует транзакцию `IDBTransaction` в режиме `readwrite`. Транзакция либо применяется полностью, либо откатывается — роль никогда не окажется в повреждённом состоянии.

```typescript
// IndexedDB — транзакционно
const transaction = db.transaction([this.storeName], 'readwrite');
const store = transaction.objectStore(this.storeName);
store.put(item); // откатится целиком при ошибке
```

### 4. Структура данных

localStorage — это хранилище строк: `key → string`. Для хранения объектов необходим `JSON.stringify` при записи и `JSON.parse` при чтении каждый раз. `LocalStorageAdapter.getAll()` итерирует по всем ключам хранилища в поиске ключей с нужным префиксом — O(n) по общему числу ключей в localStorage всего сайта.

IndexedDB — это объектное хранилище с keyPath. Роли хранятся как структурированные объекты, `getAll()` — это нативная операция object store, не итерация строк.

```typescript
// localStorage — O(n) итерация по всем ключам
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  if (key?.startsWith(this.prefix)) { ... }
}

// IndexedDB — нативный getAll()
const request = store.getAll(); // O(1) запрос
```

---

## Почему localStorage для настроек

Настройки (язык, тема) — это два-три примитивных значения. Для них IndexedDB избыточен:

- Async API IndexedDB добавляет задержку при инициализации — тема должна примениться до первого рендера, иначе будет мерцание (FOUC)
- Синхронный `localStorage.getItem()` читается мгновенно при старте приложения
- Объём — несколько байт, лимиты localStorage нерелевантны
- Транзакционность не нужна — потеря настройки темы при сбое не критична

```typescript
// Тема читается синхронно при инициализации — нет FOUC
const theme = localStorage.getItem('openrml-settings:theme') ?? 'dark';
document.documentElement.setAttribute('data-theme', theme);
```

---

## Почему sessionStorage для кеша шаблонов

Шаблоны — это встроенные данные приложения, не пользовательские данные. Они:
- Загружаются динамически при открытии Dashboard
- Не должны накапливаться между сессиями (при обновлении приложения нужны свежие шаблоны)
- Не требуют устойчивости — при следующем открытии приложения загрузятся заново

sessionStorage очищается автоматически при закрытии вкладки — именно нужное поведение для кеша.

---

## Рассмотренные альтернативы

**Всё в localStorage.** Проще в реализации — один адаптер, синхронный API. Отклонено из-за ограничений по объёму, отсутствия транзакций и поведения Safari ITP для растущих библиотек ролей.

**Всё в IndexedDB.** Единообразно. Отклонено потому что настройки темы нужны синхронно до первого рендера. Async IndexedDB для примитивных настроек — избыточная сложность с реальным UX-эффектом (мерцание темы).

**Cookie.** Устаревший механизм для данных приложения, лимит 4КБ, передаётся с каждым HTTP-запросом (нарушение принципа локальности). Не рассматривался серьёзно.

**OPFS (Origin Private File System).** Современный API, значительно быстрее IndexedDB для больших объёмов. Отклонён из-за слабой поддержки Safari на момент принятия решения и избыточности для текущих объёмов данных. Может быть пересмотрен в 0.3.0+.

---

## Последствия

**Положительные:**
- Роли защищены транзакциями — нет риска частичной записи
- Нет практического лимита на размер библиотеки ролей
- Тема применяется синхронно — нет мерцания при загрузке
- Кеш шаблонов самоочищается — нет накопления устаревших данных

**Отрицательные:**
- Три разных адаптера вместо одного — больше кода в `CompositeStorageAdapter`
- IndexedDB async API сложнее в тестировании (нужен мок или реальный браузер)
- Данные в IndexedDB сложнее инспектировать вручную, чем строки в localStorage

**Нейтральные:**
- `StoragePort` скрывает детали реализации от use-cases — смена адаптера не требует изменений в бизнес-логике
